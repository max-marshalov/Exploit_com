from django.shortcuts import render
from django.shortcuts import redirect
from django.shortcuts import get_object_or_404
from django.http import HttpResponse
from .models import Article
from .models import Category
from django.views.generic import View
from .utils import ObjectDetailMixin
from django.views.generic.edit import CreateView
from django.urls import reverse_lazy
from django.views.generic.edit import FormView
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.forms import AuthenticationForm
from django.http import HttpResponseRedirect
from django.contrib.auth import logout
from .forms import ArticleForm
from django.contrib.auth.mixins import LoginRequiredMixin
from django.db.models import Q
from django.urls import reverse
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
# Функция для установки сессионного ключа.
# По нему django будет определять, выполнил ли вход пользователь.
from django.contrib.auth import login

class RegisterFormView(FormView):
    form_class = UserCreationForm

    # Ссылка, на которую будет перенаправляться пользователь в случае успешной регистрации.
    # В данном случае указана ссылка на страницу входа для зарегистрированных пользователей.
    success_url = '/enter'

    # Шаблон, который будет использоваться при отображении представления.
    template_name = "mainPage/register.html"

    def form_valid(self, form):
        # Создаём пользователя, если данные в форму были введены корректно.
        form.save()

        # Вызываем метод базового класса
        return super(RegisterFormView, self).form_valid(form)

#Опять же, спасибо django за готовую форму аутентификации.

class LoginFormView(FormView):
    form_class = AuthenticationForm

    # Аналогично регистрации, только используем шаблон аутентификации.
    template_name = "mainPage/login.html"

    # В случае успеха перенаправим на в личный кабинет.
    success_url = "/personal_area"

    def form_valid(self, form):
        # Получаем объект пользователя на основе введённых в форму данных.
        self.user = form.get_user()

        # Выполняем аутентификацию пользователя.
        login(self.request, self.user)
        return super(LoginFormView, self).form_valid(form)

class LogoutView(View):
    def get(self, request):
        # Выполняем выход для пользователя, запросившего данное представление.
        logout(request)

        # После чего, перенаправляем пользователя на главную страницу.
        return HttpResponseRedirect("/")
#специальный класс, который забирает сатью из базы данных по id и отображает в конкретном шаблоне
class ArticleDetail(View):
     def get(self, request, id):
          #article = Article.objects.get(id=id)
          article = get_object_or_404(Article, id=id)
          return render(request, 'mainPage/art_detail.html', context={'art':article})


#класс для создания статьи 
class ArticleCreate(LoginRequiredMixin,CreateView):
     template_name = 'mainPage/add_article.html'
     form_class = ArticleForm
     success_url = "/"
     raise_exception = True
     #соотношение к категориям
     def get_context_data(self, **kwargs):
          context = super().get_context_data(**kwargs)
          context['cats'] = Category.objects.all()
          return context 
     #проверка валидности формы и привязка статьи к автору
     def form_valid(self, form):
          self.object = form.save(commit=False)
          self.object.author = self.request.user
          self.object.save()
          return super().form_valid(form)

# класс для редактирования статьи
class ArticleUpdate(LoginRequiredMixin, View):
     #получение заполненной формы по id
     def get(self, request, id):
          article = Article.objects.get(id=id)
          bound_form = ArticleForm(instance=article)
          return render(request, 'mainPage/article_update_form.html', context={'form': bound_form, 'art':article})
     #сохранение редактированной формы
     def post(self, request, id):
          article = Article.objects.get(id=id)
          bound_form = ArticleForm(request.POST, instance=article)

          if bound_form.is_valid():
               new_article = bound_form.save(commit=False)
               new_article.author = self.request.user
               new_article.save()
               return redirect(reverse('index'))
          return render(request, 'mainPage/article_update_form.html', context={'form': bound_form, 'art':article})


# функция для удаления статьи по id
@login_required
def article_delete(request, id):
     article = Article.objects.get(id=id)
     article.delete()
     return redirect(reverse('personal_area'))
# функцмя для отображения личного кабинета
def personal_area(request):
     nickname = request.user.username
     return render(request, 'mainPage/personal_area.html', context={'nick':nickname, 'arts': Article.objects.filter(author=request.user)})
# сортировка статей по категориям
def by_cat(request, cat_id):
     article = Article.objects.filter(category=cat_id)
     categories = Category.objects.all()
     current_cat = get_object_or_404(Category, pk=cat_id)
     context = {'arts': article, 'cats' : categories, 'current_cat' : current_cat}
     return render(request, 'mainPage/mainPage.html', context)
# отображение статей по состоянию  в поисковой строке
def index(request):
     search_query = request.GET.get('search', '')
     if search_query:
          arts = Article.objects.filter(Q(title__icontains=search_query) | Q(body__icontains=search_query))
          if not arts:
               arts = Article.objects.all()
     else:
          arts = Article.objects.all()
     cats = Category.objects.all()
     context = {'arts' : arts, 'cats' : cats}
     return render(request, 'mainPage/mainPage.html', context)

